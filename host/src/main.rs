use clap::{Parser, Subcommand};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{Deserialize, Serialize};
use std::fs;

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
use methods::{BITCOIN_PROOFS_ELF, BITCOIN_PROOFS_ID};

/// Bitcoin ZK Proof Daemon - Generates zero-knowledge proofs for Bitcoin block processing
#[derive(Parser)]
#[command(name = "bitcoin-zk-proofs")]
#[command(about = "A daemon that generates ZK proofs for Bitcoin block processing")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate a ZK proof for a specific Bitcoin block
    Prove {
        /// Block height to process
        #[arg(long)]
        height: u64,
        /// Output file for the proof
        #[arg(short, long, default_value = "proof.json")]
        output: String,
    },
    /// Verify a ZK proof
    Verify {
        /// Proof file to verify
        #[arg(short, long)]
        proof_file: String,
    },
    /// Run as a daemon, continuously processing new blocks
    Daemon {
        /// Starting block height
        #[arg(short, long, default_value = "0")]
        start_height: u64,
        /// Output directory for proofs
        #[arg(short, long, default_value = "./proofs")]
        output_dir: String,
    },
}

/// Input data for the ZK proof
#[derive(Debug, Clone, Serialize, Deserialize)]
struct BitcoinBlockInput {
    pub raw_block: Vec<u8>,
    pub block_height: u64,
}

/// Output data from the ZK proof
#[derive(Debug, Clone, Serialize, Deserialize)]
struct BitcoinBlockProof {
    pub block_hash: String,
    pub block_height: u64,
    pub matching_transactions: Vec<MatchingTransaction>,
    pub total_transactions: u32,
    pub matching_count: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct MatchingTransaction {
    pub txid: String,
    pub transaction_index: u32,
    pub transaction_type: String,
}

fn main() -> anyhow::Result<()> {
    // Initialize tracing
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let cli = Cli::parse();

    match cli.command {
        Commands::Prove { height, output } => {
            generate_proof(height, &output)?;
        }
        Commands::Verify { proof_file } => {
            verify_proof(&proof_file)?;
        }
        Commands::Daemon {
            start_height,
            output_dir,
        } => {
            run_daemon(start_height, &output_dir)?;
        }
    }

    Ok(())
}

/// Generates a ZK proof for a specific Bitcoin block
fn generate_proof(block_height: u64, output_file: &str) -> anyhow::Result<()> {
    println!("🔍 Fetching Bitcoin block at height {}", block_height);

    // Fetch the block from Blockstream API
    let raw_block = fetch_bitcoin_block(block_height)?;
    println!("✅ Fetched block ({} bytes)", raw_block.len());

    // Create input for the ZK proof
    let input = BitcoinBlockInput {
        raw_block,
        block_height,
    };

    println!("🔐 Generating ZK proof...");

    // Create executor environment with the block data
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Generate the proof
    let prover = default_prover();
    let prove_info = prover.prove(env, BITCOIN_PROOFS_ELF)?;
    let receipt = prove_info.receipt;

    // Extract the proof result
    let proof: BitcoinBlockProof = receipt.journal.decode()?;

    println!("✅ ZK proof generated successfully!");
    println!("   Block Hash: {}", proof.block_hash);
    println!("   Total Transactions: {}", proof.total_transactions);
    println!("   Matching Transactions: {}", proof.matching_count);

    // Save the proof to file
    let proof_data = serde_json::to_string_pretty(&proof)?;
    fs::write(output_file, proof_data)?;
    println!("💾 Proof saved to {}", output_file);

    // Verify the proof
    receipt.verify(BITCOIN_PROOFS_ID)?;
    println!("✅ Proof verification successful!");

    Ok(())
}

/// Verifies a ZK proof from file
fn verify_proof(proof_file: &str) -> anyhow::Result<()> {
    println!("🔍 Verifying proof from {}", proof_file);

    // Read the proof file
    let proof_data = fs::read_to_string(proof_file)?;
    let _proof: BitcoinBlockProof = serde_json::from_str(&proof_data)?;

    // TODO: Implement full proof verification
    // For now, we'll just verify the file can be parsed
    println!("✅ Proof file is valid JSON");

    Ok(())
}

/// Runs the daemon to continuously process new blocks
fn run_daemon(start_height: u64, output_dir: &str) -> anyhow::Result<()> {
    println!("🚀 Starting Bitcoin ZK Proof Daemon");
    println!("   Starting height: {}", start_height);
    println!("   Output directory: {}", output_dir);

    // Create output directory
    fs::create_dir_all(output_dir)?;

    let mut current_height = start_height;

    loop {
        match generate_proof(
            current_height,
            &format!("{}/block_{}.json", output_dir, current_height),
        ) {
            Ok(_) => {
                println!("✅ Processed block {}", current_height);
                current_height += 1;
            }
            Err(e) => {
                println!("❌ Error processing block {}: {}", current_height, e);
                // Wait before retrying
                std::thread::sleep(std::time::Duration::from_secs(10));
            }
        }
    }
}

/// Fetches a Bitcoin block from Blockstream API
fn fetch_bitcoin_block(height: u64) -> anyhow::Result<Vec<u8>> {
    // Get block hash
    let hash_url = format!("https://blockstream.info/api/block-height/{}", height);
    let response = reqwest::blocking::get(&hash_url)?;
    let block_hash: String = response.text()?;

    // Get raw block data
    let block_url = format!("https://blockstream.info/api/block/{}/raw", block_hash);
    let response = reqwest::blocking::get(&block_url)?;
    let block_data = response.bytes()?;

    Ok(block_data.to_vec())
}
