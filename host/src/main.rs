use clap::{Parser, Subcommand};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{Deserialize, Serialize};
use std::fs;

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
use methods::{BITCOIN_PROOFS_ELF, BITCOIN_PROOFS_ID};

/// Bitcoin ZK Proof Daemon - Generates zero-knowledge proofs for Bitcoin block processing
#[derive(Parser)]
#[command(name = "bitcoin-zk-proofs")]
#[command(about = "A daemon that generates ZK proofs for Bitcoin block processing")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate a ZK proof for a specific Bitcoin block
    Prove {
        /// Block height to process
        #[arg(long)]
        height: u64,
        /// Output file for the proof
        #[arg(short, long, default_value = "proof.json")]
        output: String,
        /// Strategy: "searching" or "pointing:txid:position:type"
        #[arg(long, default_value = "searching")]
        strategy: String,
    },
    /// Verify a ZK proof
    Verify {
        /// Proof file to verify
        #[arg(short, long)]
        proof_file: String,
    },
    /// Run as a daemon, continuously processing new blocks
    Daemon {
        /// Starting block height
        #[arg(short, long, default_value = "0")]
        start_height: u64,
        /// Output directory for proofs
        #[arg(short, long, default_value = "./proofs")]
        output_dir: String,
    },
}

/// Input data for the ZK proof
#[derive(Debug, Clone, Serialize, Deserialize)]
struct BitcoinBlockInput {
    pub raw_block: Vec<u8>,
    pub block_height: u64,
    pub strategy: ProofStrategy,
}

/// Output data from the ZK proof (re-exported from methods)
use methods::types::{
    BitcoinBlockProof, PointingProof, ProofStrategy, SearchingProof, TransactionPattern,
    TransactionType,
};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct MatchingTransaction {
    pub txid: String,
    pub transaction_index: u32,
    pub transaction_type: String,
}

fn main() -> anyhow::Result<()> {
    // Initialize tracing
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let cli = Cli::parse();

    match cli.command {
        Commands::Prove {
            height,
            output,
            strategy,
        } => {
            generate_proof(height, &output, &strategy)?;
        }
        Commands::Verify { proof_file } => {
            verify_proof(&proof_file)?;
        }
        Commands::Daemon {
            start_height,
            output_dir,
        } => {
            run_daemon(start_height, &output_dir)?;
        }
    }

    Ok(())
}

/// Generates a ZK proof for a specific Bitcoin block
fn generate_proof(block_height: u64, output_file: &str, strategy_str: &str) -> anyhow::Result<()> {
    println!("ðŸ” Fetching Bitcoin block at height {}", block_height);

    // Fetch the block from Blockstream API
    let raw_block = fetch_bitcoin_block(block_height)?;
    println!("âœ… Fetched block ({} bytes)", raw_block.len());

    // Parse strategy
    let strategy = parse_strategy(strategy_str)?;
    println!("Using strategy: {:?}", strategy);

    // Create input for the ZK proof
    let input = BitcoinBlockInput {
        raw_block,
        block_height,
        strategy,
    };

    println!("ðŸ” Generating ZK proof...");

    // Create executor environment with the block data
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Generate the proof using Groth16 (remote proving via Bonsai)
    // Bonsai will automatically use Groth16 when BONSAI_API_KEY is set
    let prover = default_prover();
    let prove_info = prover.prove(env, BITCOIN_PROOFS_ELF)?;
    let receipt = prove_info.receipt;

    // Extract the proof result
    let proof: BitcoinBlockProof = receipt.journal.decode()?;

    println!("âœ… ZK proof generated successfully!");
    println!("   Block Hash: {}", proof.block_hash);
    println!("   Total Transactions: {}", proof.total_transactions);
    println!("   Matching Transactions: {}", proof.matching_count);

    // Save the proof to file
    let proof_data = serde_json::to_string_pretty(&proof)?;
    fs::write(output_file, proof_data)?;
    println!("ðŸ’¾ Proof saved to {}", output_file);

    // Verify the proof
    receipt.verify(BITCOIN_PROOFS_ID)?;
    println!("âœ… Proof verification successful!");

    Ok(())
}

/// Verifies a ZK proof from file
fn verify_proof(proof_file: &str) -> anyhow::Result<()> {
    println!("ðŸ” Verifying proof from {}", proof_file);

    // Read the proof file
    let proof_data = fs::read_to_string(proof_file)?;
    let _proof: BitcoinBlockProof = serde_json::from_str(&proof_data)?;

    // TODO: Implement full proof verification
    // For now, we'll just verify the file can be parsed
    println!("âœ… Proof file is valid JSON");

    Ok(())
}

/// Runs the daemon to continuously process new blocks
fn run_daemon(start_height: u64, output_dir: &str) -> anyhow::Result<()> {
    println!("ðŸš€ Starting Bitcoin ZK Proof Daemon");
    println!("   Starting height: {}", start_height);
    println!("   Output directory: {}", output_dir);

    // Create output directory
    fs::create_dir_all(output_dir)?;

    let mut current_height = start_height;

    loop {
        match generate_proof(
            current_height,
            &format!("{}/block_{}.json", output_dir, current_height),
            "searching",
        ) {
            Ok(_) => {
                println!("âœ… Processed block {}", current_height);
                current_height += 1;
            }
            Err(e) => {
                println!("âŒ Error processing block {}: {}", current_height, e);
                // Wait before retrying
                std::thread::sleep(std::time::Duration::from_secs(10));
            }
        }
    }
}

/// Fetches a Bitcoin block from Blockstream API
fn fetch_bitcoin_block(height: u64) -> anyhow::Result<Vec<u8>> {
    // Get block hash
    let hash_url = format!("https://blockstream.info/api/block-height/{}", height);
    let response = reqwest::blocking::get(&hash_url)?;
    let block_hash: String = response.text()?;

    // Get raw block data
    let block_url = format!("https://blockstream.info/api/block/{}/raw", block_hash);
    let response = reqwest::blocking::get(&block_url)?;
    let block_data = response.bytes()?;

    Ok(block_data.to_vec())
}

/// Parse strategy string into ProofStrategy enum
fn parse_strategy(strategy_str: &str) -> anyhow::Result<ProofStrategy> {
    if strategy_str == "searching" {
        Ok(ProofStrategy::Searching(SearchingProof {
            pattern: TransactionPattern::All,
        }))
    } else if strategy_str.starts_with("pointing:") {
        let parts: Vec<&str> = strategy_str.split(':').collect();
        if parts.len() != 4 {
            return Err(anyhow::anyhow!(
                "Invalid pointing strategy format. Expected: pointing:txid:position:type"
            ));
        }

        let txid = parts[1].to_string();
        let position = parts[2]
            .parse::<u32>()
            .map_err(|e| anyhow::anyhow!("Invalid position: {}", e))?;
        let tx_type = match parts[3] {
            "burn" => TransactionType::Burn,
            "da" => TransactionType::DataAvailability,
            "fill" => TransactionType::Fill,
            _ => return Err(anyhow::anyhow!("Invalid transaction type: {}", parts[3])),
        };

        Ok(ProofStrategy::Pointing(PointingProof {
            txid,
            tx_position: position,
            expected_type: tx_type,
        }))
    } else {
        Err(anyhow::anyhow!(
            "Invalid strategy. Use 'searching' or 'pointing:txid:position:type'"
        ))
    }
}
